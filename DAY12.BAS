1000 REM Advent of Code 2022 - Day 12 - Hill Climbing
1010 '
1020 REM Using Dijkstra's Algorithm
1030 REM The full data set is 83 cols by 41 rows
1040 REM The test data is 8x5
1050 REM The priority queue is implemented as a heap
1060 DEFINT A-Z
1070 DEF FN RC(R,C)=R*COLS+C
1071 DEF FN UP(N)=N-COLS
1072 DEF FN DN(N)=N+COLS
1073 DEF FN LF(N)=N-1
1074 DEF FN RT(N)=N+1
1099 '
1100 REM Fill the grid in with "super high" values
1110 ROWS=43: COLS=85: DIM HT(ROWS*COLS)
1120 FOR I=0 TO ROWS*COLS: HT(I)=9000: NEXT I
1150 R=1
1155 OPEN "day12.txt" FOR INPUT AS #1
1160 WHILE NOT EOF(1)
1170  LINE INPUT #1,L$
1180  FOR C=1 TO LEN(L$)
1190   V$=MID$(L$,C,1): N=FN RC(R,C)
1195   N=FNRC(R,C)
1200   HT(N)=ASC(V$)-ASC("a")
1210   IF V$="S" THEN HT(N)=0: START=N
1220   IF V$="E" THEN HT(N)=25: DEST=N
1230  NEXT C
1240  R=R+1
1250 WEND: CLOSE #1
1255 OPEN "DAY12.LOG" FOR OUTPUT AS #1
1260 GOSUB 3000: REM Part 1
1270 IF FOUND THEN PRINT "Part 1=";DST(DEST): ELSE PRINT "Not found"
1280 END
2000 '
2100 REM Dump Heap
2110  PRINT "Heap ";:FOR C=1 TO HC: PRINT HP(C);: NEXT C: PRINT
2120 RETURN
2130 '
2200 REM ENQUEUE(N)
2201 REM Note that DST(HP(x)) is the sorting criteria
2210 HC=HC+1
2215 DN=DST(N)
2220 C = HC: T=HP(C)
2230 WHILE C > 1 AND DST(HP(C\2)) > DN
2240  HP(C)=HP(C\2)
2250  C=C\2
2260 WEND
2270 HP(C)=N
2280 PRINT#1,"ENQUEUE ";DN;HC
2290 RETURN
2299 '
2300 REM N=DEQUEUE
2301  REM Note that DST is the sorting criteria,
2302  REM and the heap contains indicies into DST
2310  IF HC=0 THEN PRINT#1,"Heap error": END
2315  N=HP(1): HC=HC-1
2316  PRINT#1,"(";(N\COLS);",";(N MOD COLS);") DEQUEUED DIST=";DST(N);HC
2320  HP(1)=HP(HC+1)
2330  IF HC=1 THEN RETURN
2340  R=1
2350  C=R*2: IF C>HC THEN 2400
2360   IF C<HC AND DST(HP(C)) > DST(HP(C+1)) THEN C=C+1:
2370   IF DST(HP(R)) <= DST(HP(C)) THEN 2400
2380   SWAP HP(R), HP(C): R=C
2390  GOTO 2350
2400 RETURN
2410 '
2500 REM Evaluate V against I (Internal to Dikjstra's below)
2505  PRINT#1,"(";(V\COLS);",";(V MOD COLS);") ";
2510  IF HT(V)>HT(I)+1 THEN PRINT#1,"IMPASSABLE": RETURN
2520  IF PREV(V)<>-1 THEN PRINT#1,"VISITED ALREADY": RETURN
2530  A=DST(I)+1
2540  DST(V)=A: PREV(V)=I
2550  N=V: GOSUB 2200: REM ENQUEUE(I)
2560 RETURN
2570 '
3000 REM Dijkstra's Algorithm
3010 '
3020 SZ=(ROWS+1)*COLS
3030 DIM DST(SZ), PREV(SZ), HP(SZ*4)
3040 PRINT "Dijkstra",SZ
3041 PRINT "Start (";(START\COLS);",";(START MOD COLS);")"
3042 PRINT "End   (";(DEST\COLS);",";(DEST MOD COLS);")"
3050 '
3100 REM Initialize
3110 FOR R=0 TO ROWS: FOR C=0 TO COLS
3120   N=FN RC(R,C)
3130   DST(N)=SZ: REM Max Distance
3140   PREV(N)=-1: REM FNRC(R,C)
3150 NEXT C: NEXT R
3160 N=START: DST(N)=0: PREV(N)=0: GOSUB 2200
3170 '
3200 REM Run Search
3205 FOUND=0
3210 WHILE HC>0 AND NOT FOUND
3220  PRINT#1,"": GOSUB 2300: I=N: REM DEQUEUE I
3230  IF I=DEST THEN FOUND=I: GOTO 3290 
3250  V=FN UP(I): GOSUB 2500 
3260  V=FN DN(I): GOSUB 2500 
3270  V=FN LF(I): GOSUB 2500 
3280  V=FN RT(I): GOSUB 2500 
3290 WEND
3300 RETURN
